from typing import NamedTuple, List
import math

A='A'
B='B'
C='C'
D='D'
E='E'
F='F'
G='G'
逃げ='逃げ'
先行='先行'
差し='差し'
追込='追込'
絶好調='絶好調'
好調='好調'
普通='普通'
不調='不調'
絶不調='絶不調'

class ステータス(NamedTuple):
    スピード: float
    スタミナ: float
    パワー: float
    根性: float
    賢さ: float

    脚質: str
    脚質適性: str
    距離適性: str
    バ場適性: str

class ウマ状態(NamedTuple):
    掛かり: bool
    ペースダウン: bool
    下り坂加速: bool

class 状態(NamedTuple):
    現在速度: float
    残りHP: float
    フェーズ: int
    ウマ状態: ウマ状態

    ラストスパート基準速度: float
    ラストスパート開始位置: float  # 残り何mから開始するか

class コース(NamedTuple):
    距離: float
    バ場種類: str
    バ場状態: str

def ステータス補正(生ステータス: ステータス, やる気: str, コース: コース) -> ステータス:
    やる気係数 = {
        '絶好調': 1.04,
        '好調': 1.02,
        '普通': 1.0,
        '不調': 0.98,
        '絶不調': 0.96,
    }[やる気]
    コース係数 = 1.0 # TODO
    バ場補正_スピード = {
        '不良': -50,
        '重': 0,
        '稍重': 0,
        '良': 0,
    }[コース.バ場状態]
    バ場補正_パワー = {
        '不良': -50,
        '重': -50,
        '稍重': -50,
        '良': 0,
    }[コース.バ場状態]
    脚質補正 = {
        'S': 1.1,
        'A': 1.0,
        'B': 0.85,
        'C': 0.75,
        'D': 0.6,
        'E': 0.4,
        'F': 0.2,
        'G': 0.1,
    }[生ステータス.脚質適性]
    return ステータス(
        スピード=生ステータス.スピード * やる気係数 * コース係数 + バ場補正_スピード,
        スタミナ=生ステータス.スタミナ * やる気係数,
        パワー=生ステータス.パワー * やる気係数 + バ場補正_パワー,
        根性=生ステータス.根性 * やる気係数,
        賢さ=生ステータス.賢さ * やる気係数 * 脚質補正,

        脚質=生ステータス.脚質,
        脚質適性=生ステータス.脚質適性,
        距離適性=生ステータス.距離適性,
        バ場適性=生ステータス.バ場適性,
    )

def 初期HP(補正ステータス: ステータス, コース: コース) -> float:
    脚質係数 = {
        '逃げ': 0.95,
        '先行': 0.89,
        '差し': 1.0,
        '追込': 0.995,
    }[補正ステータス.脚質]
    return 0.8 * 脚質係数 * 補正ステータス.スタミナ + コース.距離

def ウマ状態係数(状態: 状態) -> float:
    k = 1.0
    if 状態.ウマ状態.掛かり: k *= 1.6
    if 状態.ウマ状態.ペースダウン: k *= 0.6
    if 状態.ウマ状態.下り坂加速: k *= 0.4
    return k

def 秒間体力消費_基本(状態: 状態, コース: コース) -> float:
    バ場状態係数 = {
        '芝': {
            '不良': 1.02,
            '重': 1.02,
            '稍重': 1,
            '良': 1,
        },
        'ダート': {
            '不良': 1.02,
            '重': 1.01,
            '稍重': 1,
            '良': 1,
        },
    }[コース.バ場種類][コース.バ場状態]
    return 20.0 * ウマ状態係数(状態) * (状態.現在速度 - 基準速度(コース) + 12.0)**2 / 144.0 * バ場状態係数

def 秒間体力消費(状態: 状態, コース: コース, 補正ステータス: ステータス) -> float:
    ret = 秒間体力消費_基本(状態, コース)
    if 状態.フェーズ >= 2:
        ret *= 200.0 / math.sqrt(600.0 * 補正ステータス.根性) + 1.0
    return ret

def 基準速度(コース: コース) -> float:
    return 20.0 - (コース.距離 - 2000) / 1000

def 賢さ乱数_期待値(補正賢さ: float) -> float:
    上限 = (補正賢さ / 5500) * math.log10(補正賢さ * 0.1)
    下限 = 上限 - 0.65
    return (上限 + 下限) / 2.0

def 基準目標速度(状態: 状態, コース: コース, 補正ステータス: ステータス) -> float:
    脚質係数 = {
        '逃げ': [1.0,   0.98,  0.962, 0.962],
        '先行': [0.978, 0.991, 0.975, 0.975],
        '差し': [0.938, 0.998, 0.994, 0.994],
        '追込': [0.931, 1.0,   1.0,   1.0],
    }[補正ステータス.脚質][状態.フェーズ]
    距離適性係数 = {
        'S': 1.05,
        'A': 1.0,
        'B': 0.9,
        'C': 0.8,
        'D': 0.6,
        'E': 0.4,
        'F': 0.2,
        'G': 0.1,
    }[補正ステータス.距離適性]

    ret = 基準速度(コース) * 脚質係数 + (賢さ乱数_期待値(補正ステータス.賢さ) * 基準速度(コース))
    if 状態.フェーズ >= 2:
        ret += math.sqrt(500.0 * 補正ステータス.スピード) * 距離適性係数 * 0.002
    return ret

def 目標速度(状態: 状態, コース: コース, 補正ステータス: ステータス) -> float:
    # 実際にはポジションキープや移動補正などに影響されるが、未実装
    return 基準目標速度(状態, コース, 補正ステータス)

def 加速度(状態: 状態, 補正ステータス: ステータス) -> float:
    脚質係数 = {
        '逃げ': [1.0,   1.0, 0.996, 0.996],
        '先行': [0.985, 1.0, 0.996, 0.996],
        '差し': [0.975, 1.0, 1.0,   1.0],
        '追込': [0.945, 1.0, 0.997, 0.997],
    }[補正ステータス.脚質][状態.フェーズ]
    バ場適性係数 = {
        'S': 1.05,
        'A': 1.0,
        'B': 0.9,
        'C': 0.8,
        'D': 0.6,
        'E': 0.4,
        'F': 0.2,
        'G': 0.1,
    }[補正ステータス.バ場適性]
    距離適性係数 = {
        'S': 1.0,
        'A': 1.0,
        'B': 1.0,
        'C': 1.0,
        'D': 1.0,
        'E': 0.6,
        'F': 0.5,
        'G': 0.4,
    }[補正ステータス.距離適性]
    return 0.0006 * math.sqrt(500.0 * 補正ステータス.パワー) * 脚質係数 * バ場適性係数 * 距離適性係数

def スタートダッシュ加速度(状態: 状態, 補正ステータス: ステータス) -> float:
    return 加速度(状態, 補正ステータス) + 24.0

def スタートダッシュ制限速度(コース: コース) -> float:
    return 基準速度(コース) * 0.85

def 最低速度(コース: コース, 補正ステータス: ステータス) -> float:
    return 基準速度(コース) * 0.85 + math.sqrt(200.0 * 補正ステータス.根性) * 0.001

################################################################################

FPS = 15.0

def next_velocity(curr_vel: float, curr_acc: float, target_vel: float) -> float:
    '''次のフレームの速度を返す'''
    # [s] = [15f]
    # [m/s^2] -> [m/f^2]
    a = curr_acc / (FPS * FPS)
    # [m/s] -> [m/f]
    v = curr_vel / FPS
    # [m/f] -> [m/s]
    next_vel = (v+a) * FPS
    return min(next_vel, target_vel)

class SimulationResult(NamedTuple):
    残り距離: List[float]
    残りHP: List[float]
    速度: List[float]
    加速度: List[float]

def simulate(生ステータス: ステータス, コース: コース, やる気: str):
    status = ステータス補正(生ステータス, やる気, コース)
    state = 状態(
        現在速度=0.0,
        残りHP=初期HP(status, コース),
        フェーズ=0,
        ウマ状態=ウマ状態(掛かり=False, ペースダウン=False, 下り坂加速=False),
        ラストスパート基準速度=None,
        ラストスパート開始位置=None,
    )

    result = SimulationResult(
        残り距離=[],
        残りHP=[],
        速度=[],
        加速度=[],
    )

    frame = 0
    rest_distance = コース.距離

    while rest_distance > 0.0:
        if frame < 8:
            # スタートダッシュ
            a = スタートダッシュ加速度(state, status)
            v_min = 0.0
            v_max = スタートダッシュ制限速度(コース)
        else:
            a = 加速度(state, status)
            v_min = 最低速度(コース, status)
            v_max = 1e8

        next_v = next_velocity(state.現在速度, a, 目標速度(state, コース, status))
        next_v = max(next_v, v_min)
        next_v = min(next_v, v_max)

        rest_distance -= next_v / FPS

        state = state._replace(
            現在速度=next_v,
            残りHP=state.残りHP - 秒間体力消費(state, コース, status) / FPS,
        )

        result.残り距離.append(rest_distance)
        result.残りHP.append(state.残りHP)
        result.速度.append(state.現在速度)
        result.加速度.append(a)

        frame += 1

    return result
